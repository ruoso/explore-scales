<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Harmonic Scale Explorer - Extended String Instruments with Query Parameters and Flat Support</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f7f7f7;
      margin: 0;
      padding: 20px;
    }
    .container {
      max-width: 1000px;
      margin: auto;
      background: #fff;
      padding: 20px 30px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    h1 {
      text-align: center;
      color: #333;
    }
    .form-group {
      margin-bottom: 15px;
    }
    label {
      display: block;
      font-weight: bold;
      margin-bottom: 5px;
      color: #555;
    }
    input[type="text"], select {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    button.submit-btn {
      display: block;
      width: 100%;
      padding: 10px;
      background: #007BFF;
      color: #fff;
      font-size: 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
    }
    button.submit-btn:hover {
      background: #0056b3;
    }
    .result {
      margin-top: 25px;
    }
    .scale-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      text-align: center;
    }
    .scale-table th, .scale-table td {
      border: 1px solid #ddd;
      padding: 8px;
      vertical-align: middle;
    }
    .scale-header {
      background: #f0f0f0;
      font-weight: bold;
    }
    .chord-details {
      font-size: 0.9em;
      color: #333;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Harmonic Scale Explorer</h1>
    <form id="scaleForm">
      <div class="form-group">
        <label for="tonic">Tonic Chord</label>
        <!-- User may enter flats like "Bb" -->
        <input type="text" id="tonic" placeholder="e.g., C or Bb" required>
      </div>
      <div class="form-group">
        <label for="scaleType">Scale Type</label>
        <select id="scaleType" required>
          <option value="major">Major</option>
          <option value="minor">Natural Minor</option>
          <option value="harmonicMinor">Harmonic Minor</option>
        </select>
      </div>
      <div class="form-group">
        <label for="instrument">Instrument</label>
        <select id="instrument" required>
          <!-- List of string instruments only -->
          <option value="6guitar">6‑String Guitar</option>
          <option value="7guitar">7‑String Guitar</option>
          <option value="4bass">4‑String Bass</option>
          <option value="5bass">5‑String Bass</option>
          <option value="violin">Violin</option>
          <option value="viola">Viola</option>
          <option value="cello">Cello</option>
          <option value="ukulele">Ukulele</option>
          <option value="mandolin">Mandolin</option>
        </select>
      </div>
      <!-- Tuning controls will appear for instruments that support tunings -->
      <div class="form-group" id="tuningGroup"></div>
      <button type="submit" class="submit-btn">Generate Chords</button>
    </form>
    <div id="results" class="result"></div>
  </div>

  <script>
    // ============================
    // Global Constants and Tuning Presets
    // ============================
    const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    
    const tuningPresets = {
      "6guitar": [
        { name: "Standard", tuning: "E2, A2, D3, G3, B3, E4" },
        { name: "Drop D", tuning: "D2, A2, D3, G3, B3, E4" },
        { name: "Open G", tuning: "D2, G2, D3, G3, B3, D4" },
        { name: "Open D", tuning: "D2, A2, D3, F#3, A3, D4" },
        { name: "DADGAD", tuning: "D2, A2, D3, G3, A3, D4" },
        { name: "Open C", tuning: "C2, G2, C3, G3, E3, G3" }
      ],
      "7guitar": [
        { name: "Standard", tuning: "B1, E2, A2, D3, G3, B3, E4" },
        { name: "Brazilian", tuning: "C1, E2, A2, D3, G3, B3, E4" }
      ],
      "4bass": [
        { name: "Standard", tuning: "E1, A1, D2, G2" }
      ],
      "5bass": [
        { name: "Standard", tuning: "B0, E1, A1, D2, G2" }
      ],
      "violin": [
        { name: "Standard", tuning: "G3, D4, A4, E5" }
      ],
      "viola": [
        { name: "Standard", tuning: "C3, G3, D4, A4" }
      ],
      "cello": [
        { name: "Standard", tuning: "C2, G2, D3, A3" }
      ],
      "ukulele": [
        { name: "Standard (Re-entrant)", tuning: "G4, C4, E4, A4" }
      ],
      "mandolin": [
        { name: "Standard", tuning: "G3, D4, A4, E5" }
      ]
    };

    // ============================
    // Helper Functions
    // ============================
    // Parse a tuning string into an array of objects { note, octave }
    function parseGuitarTuning(tuningStr) {
      let parts = tuningStr.split(",");
      let tuning = [];
      for (let part of parts) {
        part = part.trim();
        let match = part.match(/^([A-G][#]?)(\d+)$/);
        if (match) {
          tuning.push({ note: match[1], octave: parseInt(match[2], 10) });
        }
      }
      return tuning;
    }

    // If a note is flat (e.g., "Bb"), convert to its sharp equivalent (e.g., "A#")
    function convertFlatToSharp(note) {
      const flatToSharp = { "Bb": "A#", "Db": "C#", "Eb": "D#", "Gb": "F#", "Ab": "G#" };
      return flatToSharp[note] || note;
    }

    // ============================
    // Chord and Scale Mappings
    // ============================
    const chordQualities = {
      major: ["major", "minor", "minor", "major", "major", "minor", "diminished"],
      minor: ["minor", "diminished", "major", "minor", "minor", "major", "major"],
      harmonicMinor: ["minor", "diminished", "augmented", "minor", "major", "major", "diminished"]
    };

    const romanMapping = {
      major: ["I", "ii", "iii", "IV", "V", "vi", "vii°"],
      minor: ["i", "ii°", "III", "iv", "v", "VI", "VII"],
      harmonicMinor: ["i", "ii°", "III+", "iv", "V", "VI", "vii°"]
    };

    const functionsMapping = {
      major: ["Tonic", "Supertonic", "Mediant", "Subdominant", "Dominant", "Submediant", "Leading Tone"],
      minor: ["Tonic", "Supertonic", "Mediant", "Subdominant", "Dominant", "Submediant", "Subtonic"],
      harmonicMinor: ["Tonic", "Supertonic", "Mediant", "Subdominant", "Dominant", "Submediant", "Leading Tone"]
    };

    // ============================
    // Tuning Controls and Query Parameter Functions
    // ============================
    const instrumentSelect = document.getElementById("instrument");
    const tuningGroup = document.getElementById("tuningGroup");
    instrumentSelect.addEventListener("change", function() {
      populateTuningControls(this.value);
      updateQueryFromForm();
    });
    instrumentSelect.dispatchEvent(new Event("change"));

    function populateTuningControls(instrument) {
      let presets = tuningPresets[instrument];
      tuningGroup.innerHTML = "";
      if (!presets) {
        tuningGroup.style.display = "none";
        return;
      }
      tuningGroup.style.display = "block";
      let presetLabel = document.createElement("label");
      presetLabel.setAttribute("for", "tuningPreset");
      presetLabel.textContent = "Tuning Preset:";
      tuningGroup.appendChild(presetLabel);
      let presetSelect = document.createElement("select");
      presetSelect.id = "tuningPreset";
      for (let preset of presets) {
        let option = document.createElement("option");
        option.value = preset.tuning;
        option.textContent = preset.name + " (" + preset.tuning + ")";
        presetSelect.appendChild(option);
      }
      tuningGroup.appendChild(presetSelect);
      let customLabel = document.createElement("label");
      customLabel.setAttribute("for", "customTuning");
      customLabel.textContent = "Custom Tuning (optional):";
      customLabel.style.marginTop = "10px";
      tuningGroup.appendChild(customLabel);
      let customInput = document.createElement("input");
      customInput.type = "text";
      customInput.id = "customTuning";
      customInput.placeholder = "e.g., E2, A2, D3, G3, B3, E4";
      tuningGroup.appendChild(customInput);
    }

    function getQueryParams() {
      let params = {};
      let search = window.location.search;
      if (search.length > 1) {
        search.substring(1).split("&").forEach(function(item) {
          let parts = item.split("=");
          params[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1] || "");
        });
      }
      return params;
    }

    function populateFormFromQuery() {
      const params = getQueryParams();
      if (params.tonic) {
        document.getElementById("tonic").value = params.tonic;
      }
      if (params.scaleType) {
        document.getElementById("scaleType").value = params.scaleType;
      }
      if (params.instrument) {
        document.getElementById("instrument").value = params.instrument;
        instrumentSelect.dispatchEvent(new Event("change"));
      }
      if (params.tuningPreset && document.getElementById("tuningPreset")) {
        document.getElementById("tuningPreset").value = params.tuningPreset;
      }
      if (params.customTuning && document.getElementById("customTuning")) {
        document.getElementById("customTuning").value = params.customTuning;
      }
    }

    function updateQueryFromForm() {
      const tonic = document.getElementById("tonic").value.trim();
      const scaleType = document.getElementById("scaleType").value;
      const instrument = document.getElementById("instrument").value;
      let tuningPreset = "";
      let customTuning = "";
      if (tuningPresets[instrument]) {
        tuningPreset = document.getElementById("tuningPreset").value;
        customTuning = document.getElementById("customTuning").value.trim();
      }
      const params = new URLSearchParams();
      params.set("tonic", tonic);
      params.set("scaleType", scaleType);
      params.set("instrument", instrument);
      if (tuningPreset) params.set("tuningPreset", tuningPreset);
      if (customTuning) params.set("customTuning", customTuning);
      history.replaceState(null, "", "?" + params.toString());
    }

    // ============================
    // Core Calculation Functions
    // ============================
    function computeScale(tonic, scaleType) {
      let intervals;
      if (scaleType === "major") {
        intervals = [2, 2, 1, 2, 2, 2, 1];
      } else if (scaleType === "minor") {
        intervals = [2, 1, 2, 2, 1, 2, 2];
      } else if (scaleType === "harmonicMinor") {
        intervals = [2, 1, 2, 2, 1, 3, 1];
      }
      let scale = [tonic];
      let currentIndex = notes.indexOf(tonic);
      for (let i = 0; i < intervals.length - 1; i++) {
        currentIndex = (currentIndex + intervals[i]) % 12;
        scale.push(notes[currentIndex]);
      }
      return scale;
    }

    function computeChordNotes(root, quality) {
      const formulas = {
        major: [0, 4, 7],
        minor: [0, 3, 7],
        diminished: [0, 3, 6],
        augmented: [0, 4, 8]
      };
      let intervals = formulas[quality];
      let rootIndex = notes.indexOf(root);
      return intervals.map(interval => notes[(rootIndex + interval) % 12]);
    }

    function getChordSymbol(root, quality, useFlat) {
      let symbol;
      switch (quality) {
        case "major": symbol = root; break;
        case "minor": symbol = root + "m"; break;
        case "diminished": symbol = root + "°"; break;
        case "augmented": symbol = root + "+"; break;
        default: symbol = root;
      }
      if (useFlat) {
        const sharpToFlat = { "A#": "Bb", "C#": "Db", "D#": "Eb", "F#": "Gb", "G#": "Ab" };
        if (sharpToFlat[symbol]) {
          symbol = sharpToFlat[symbol];
        }
      }
      return symbol;
    }

    function getProducedPitch(tuningObj, fret) {
      let baseIndex = notes.indexOf(tuningObj.note);
      let total = baseIndex + fret;
      let producedNote = notes[total % 12];
      let octaveIncrease = Math.floor(total / 12);
      return producedNote + (tuningObj.octave + octaveIncrease);
    }

    function pitchToValue(pitch) {
      let match = pitch.match(/^([A-G]#?)(\d+)$/);
      if (!match) return null;
      let note = match[1];
      let octave = parseInt(match[2], 10);
      return notes.indexOf(note) + 12 * octave;
    }

    // ============================
    // Recursive DFS Candidate Generator
    // ============================
    function dfsCandidatesForSpan(chordNotes, tuning, minFret, maxFret, index, fundamentalFound, currentAssignment, results) {
      if (index === tuning.length) {
        results.push(currentAssignment.slice());
        return;
      }
      let options = [];
      let possible = [];
      let openNote = tuning[index].note;
      if (chordNotes.includes(openNote)) {
        possible.push({ fret: 0, produced: openNote });
      }
      for (let fret = minFret; fret <= maxFret; fret++) {
        let produced = getProducedPitch(tuning[index], fret);
        let producedNote = produced.replace(/\d/, "");
        if (chordNotes.includes(producedNote)) {
          possible.push({ fret: fret, produced: producedNote });
        }
      }
      if (!fundamentalFound) {
        let fundamentalOptions = possible.filter(opt => opt.produced === chordNotes[0]);
        options = fundamentalOptions.length > 0 ? fundamentalOptions : [];
      } else {
        options = possible;
      }
      options.push("x");
      for (let opt of options) {
        let newFundamentalFound = fundamentalFound;
        if (opt !== "x" && !fundamentalFound) {
          if (opt.produced === chordNotes[0]) {
            newFundamentalFound = true;
          }
        }
        currentAssignment.push(opt === "x" ? "x" : opt.fret.toString());
        dfsCandidatesForSpan(chordNotes, tuning, minFret, maxFret, index + 1, newFundamentalFound, currentAssignment, results);
        currentAssignment.pop();
      }
    }

    function generateCandidatesForSpan(chordNotes, tuning, minFret, maxFret) {
      let results = [];
      dfsCandidatesForSpan(chordNotes, tuning, minFret, maxFret, 0, false, [], results);
      return results;
    }

    // ============================
    // Filtering Function
    // ============================
    function filterCandidate(candidate, tuning, chordNotes) {
      let producedPitches = candidate.map((assign, i) =>
        assign === "x" ? null : getProducedPitch(tuning[i], parseInt(assign))
      );
      let firstNonMuted = producedPitches.find(p => p !== null);
      if (!firstNonMuted || firstNonMuted.replace(/\d/, "") !== chordNotes[0]) return false;
      for (let i = tuning.length - 3; i < tuning.length; i++) {
        if (producedPitches[i] === null) return false;
      }
      let pitchSet = new Set();
      for (let p of producedPitches) {
        if (p !== null) {
          if (pitchSet.has(p)) return false;
          pitchSet.add(p);
        }
      }
      for (let i = 0; i < candidate.length; i++) {
        if (candidate[i] === "x") {
          let hasBefore = candidate.slice(0, i).some(a => a !== "x");
          let hasAfter = candidate.slice(i + 1).some(a => a !== "x");
          if (hasBefore && hasAfter) return false;
        }
      }
      let nonMuted = producedPitches.filter(p => p !== null);
      let nonMutedValues = nonMuted.map(p => pitchToValue(p));
      for (let i = 0; i < nonMutedValues.length - 1; i++) {
        if (nonMutedValues[i] >= nonMutedValues[i + 1]) return false;
      }
      return true;
    }

    function computeGuitarFingerings(chordNotes, tuning) {
      let candidates = new Set();
      for (let maxFret = 3; maxFret <= 15; maxFret++) {
        let minFret = maxFret >= 4 ? maxFret - 3 : 1;
        let candidateArrays = generateCandidatesForSpan(chordNotes, tuning, minFret, maxFret);
        for (let cand of candidateArrays) {
          if (filterCandidate(cand, tuning, chordNotes)) {
            candidates.add(cand.join(" "));
          }
        }
      }
      return Array.from(candidates);
    }

    // ============================
    // SVG Rendering Function
    // ============================
    function renderChordSVG(candidateStr, tuning) {
      let candidate = candidateStr.split(" ");
      let numStrings = tuning.length;
      let pressed = candidate.filter(val => val !== "x" && val !== "0").map(val => parseInt(val));
      let displayStartFret;
      if (pressed.length === 0 || Math.max(...pressed) <= 4) {
        displayStartFret = 1;
      } else {
        displayStartFret = Math.min(...pressed);
      }
      let numFretsToShow = 4;
      let width = 120;
      let height = 160;
      let marginTop = 20;
      let marginLeft = 20;
      let stringSpacing = (width - marginLeft) / numStrings;
      let fretSpacing = (height - marginTop) / numFretsToShow;
      let svg = `<svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">`;
      for (let i = 0; i < numStrings; i++) {
        let x = marginLeft + i * stringSpacing + stringSpacing / 2;
        svg += `<line x1="${x}" y1="${marginTop}" x2="${x}" y2="${height}" stroke="black" stroke-width="1" />`;
      }
      for (let j = 0; j <= numFretsToShow; j++) {
        let y = marginTop + j * fretSpacing;
        let strokeWidth = j === 0 ? 3 : 1;
        svg += `<line x1="${marginLeft}" y1="${y}" x2="${width}" y2="${y}" stroke="black" stroke-width="${strokeWidth}" />`;
      }
      for (let i = 0; i < numStrings; i++) {
        let x = marginLeft + i * stringSpacing + stringSpacing / 2;
        let mark = candidate[i];
        if (mark === "x") {
          svg += `<text x="${x}" y="${marginTop - 5}" text-anchor="middle" font-size="12" fill="red">X</text>`;
        } else if (mark === "0") {
          svg += `<text x="${x}" y="${marginTop - 5}" text-anchor="middle" font-size="12" fill="green">O</text>`;
        }
      }
      for (let i = 0; i < numStrings; i++) {
        let mark = candidate[i];
        if (mark !== "x" && mark !== "0") {
          let fret = parseInt(mark);
          let fretPosition = fret - displayStartFret;
          let x = marginLeft + i * stringSpacing + stringSpacing / 2;
          let y = marginTop + (fretPosition + 0.5) * fretSpacing;
          svg += `<circle cx="${x}" cy="${y}" r="${stringSpacing/4}" fill="black" />`;
        }
      }
      if (displayStartFret > 1) {
        svg += `<text x="5" y="${marginTop + fretSpacing/2}" font-size="12" fill="black">${displayStartFret}</text>`;
      }
      svg += `</svg>`;
      return svg;
    }

    // ============================
    // Main Function: generateChords
    // ============================
    function generateChords(tonic, scaleType, instrument, customTuning, displayTonic) {
      let scale = computeScale(tonic, scaleType);
      let qualities = chordQualities[scaleType];
      let useFlat = displayTonic.includes("b");
      let results = [];
      for (let i = 0; i < scale.length; i++) {
        let chordRoot = scale[i];
        let quality = qualities[i];
        let chordNotes = computeChordNotes(chordRoot, quality);
        let chordSymbol = getChordSymbol(chordRoot, quality, useFlat);
        let fingerings = computeGuitarFingerings(chordNotes, customTuning);
        results.push({
          degree: romanMapping[scaleType][i],
          functionLabel: functionsMapping[scaleType][i],
          chordSymbol: chordSymbol,
          chordNotes: chordNotes,
          fingerings: fingerings
        });
      }
      return results;
    }

    // ============================
    // Form Submission Handler
    // ============================
    document.getElementById('scaleForm').addEventListener('submit', function(e) {
      e.preventDefault();
      updateQueryFromForm();
      const tonicInput = document.getElementById('tonic').value.trim();
      // Preserve the original tonic for display (e.g., "Bb")
      const displayTonic = tonicInput;
      // For computation, if tonic contains "b", convert to its sharp equivalent.
      const normalizedTonic = tonicInput.includes("b") ? convertFlatToSharp(tonicInput) : tonicInput;
      const scaleType = document.getElementById('scaleType').value;
      const instrument = document.getElementById('instrument').value;
      let customTuning = null;
      if (tuningPresets[instrument]) {
        let presetSelect = document.getElementById("tuningPreset");
        let presetTuningStr = presetSelect.value;
        let customTuningStr = document.getElementById("customTuning").value.trim();
        let tuningStr = customTuningStr !== "" ? customTuningStr : presetTuningStr;
        customTuning = parseGuitarTuning(tuningStr);
      }
      const resultsDiv = document.getElementById('results');
      resultsDiv.innerHTML = '';
      if (!normalizedTonic || (notes.indexOf(normalizedTonic) === -1 && !normalizedTonic.includes("b"))) {
        resultsDiv.innerHTML = '<p>Please enter a valid tonic note (e.g., C, C#, D, Bb, etc.).</p>';
        return;
      }
      let chords = generateChords(normalizedTonic, scaleType, instrument, customTuning, displayTonic);
      let maxFingerings = chords.reduce((max, chord) => Math.max(max, chord.fingerings.length), 0);
      let table = document.createElement('table');
      table.classList.add('scale-table');
      let degreeRow = document.createElement('tr');
      let functionRow = document.createElement('tr');
      chords.forEach(chord => {
        let tdDegree = document.createElement('td');
        tdDegree.classList.add('scale-header');
        tdDegree.textContent = chord.degree;
        degreeRow.appendChild(tdDegree);
        let tdFunction = document.createElement('td');
        tdFunction.classList.add('scale-header');
        tdFunction.textContent = chord.functionLabel;
        functionRow.appendChild(tdFunction);
      });
      table.appendChild(degreeRow);
      table.appendChild(functionRow);
      let chordInfoRow = document.createElement('tr');
      chords.forEach(chord => {
        let td = document.createElement('td');
        td.classList.add('chord-details');
        td.innerHTML = `<strong>${chord.chordSymbol}</strong><br>Notes: ${chord.chordNotes.join(", ")}`;
        chordInfoRow.appendChild(td);
      });
      table.appendChild(chordInfoRow);
      for (let i = 0; i < maxFingerings; i++) {
        let row = document.createElement('tr');
        chords.forEach(chord => {
          let td = document.createElement('td');
          td.classList.add('chord-details');
          if (chord.fingerings[i]) {
            td.innerHTML = renderChordSVG(chord.fingerings[i], customTuning);
          } else {
            td.textContent = "";
          }
          row.appendChild(td);
        });
        table.appendChild(row);
      }
      resultsDiv.appendChild(table);
    });

    // On page load, populate form from query parameters.
    window.addEventListener("DOMContentLoaded", populateFormFromQuery);
  </script>
</body>
</html>
