<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Harmonic Scale Explorer - Custom Tuning & DFS Candidate Generator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f7f7f7;
      margin: 0;
      padding: 20px;
    }
    .container {
      max-width: 950px;
      margin: auto;
      background: #fff;
      padding: 20px 30px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    h1 {
      text-align: center;
      color: #333;
    }
    .form-group {
      margin-bottom: 15px;
    }
    label {
      display: block;
      font-weight: bold;
      margin-bottom: 5px;
      color: #555;
    }
    input[type="text"], select {
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    button.submit-btn {
      display: block;
      width: 100%;
      padding: 10px;
      background: #007BFF;
      color: #fff;
      font-size: 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
    }
    button.submit-btn:hover {
      background: #0056b3;
    }
    .result {
      margin-top: 25px;
    }
    .scale-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      text-align: center;
    }
    .scale-table th, .scale-table td {
      border: 1px solid #ddd;
      padding: 8px;
      vertical-align: middle;
    }
    .scale-header {
      background: #f0f0f0;
      font-weight: bold;
    }
    .chord-details {
      font-size: 0.9em;
      color: #333;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Harmonic Scale Explorer</h1>
    <form id="scaleForm">
      <div class="form-group">
        <label for="tonic">Tonic Chord</label>
        <input type="text" id="tonic" placeholder="e.g., C" required>
      </div>
      <div class="form-group">
        <label for="scaleType">Scale Type</label>
        <select id="scaleType" required>
          <option value="major">Major</option>
          <option value="minor">Natural Minor</option>
          <option value="harmonicMinor">Harmonic Minor</option>
        </select>
      </div>
      <div class="form-group">
        <label for="instrument">Instrument</label>
        <select id="instrument" required>
          <option value="6guitar">6 String Guitar</option>
          <option value="7guitar">7 String Guitar</option>
          <option value="piano">Piano</option>
        </select>
      </div>
      <!-- Custom tuning input for guitar -->
      <div class="form-group" id="tuningGroup">
        <label for="guitarTuning">Guitar Tuning (comma separated, e.g., E2, A2, D3, G3, B3, E4)</label>
        <input type="text" id="guitarTuning" value="E2, A2, D3, G3, B3, E4">
      </div>
      <button type="submit" class="submit-btn">Generate Chords</button>
    </form>
    <div id="results" class="result"></div>
  </div>

  <script>
    // Constants and Default Tunings
    const notes = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const defaultTuning6 = "E2, A2, D3, G3, B3, E4";
    const defaultTuning7 = "B1, E2, A2, D3, G3, B3, E4";

    // Chord Quality, Roman numeral, and Functional labels
    const chordQualities = {
      major: ["major", "minor", "minor", "major", "major", "minor", "diminished"],
      minor: ["minor", "diminished", "major", "minor", "minor", "major", "major"],
      harmonicMinor: ["minor", "diminished", "augmented", "minor", "major", "major", "diminished"]
    };

    const romanMapping = {
      major: ["I", "ii", "iii", "IV", "V", "vi", "vii°"],
      minor: ["i", "ii°", "III", "iv", "v", "VI", "VII"],
      harmonicMinor: ["i", "ii°", "III+", "iv", "V", "VI", "vii°"]
    };

    const functionsMapping = {
      major: ["Tonic", "Supertonic", "Mediant", "Subdominant", "Dominant", "Submediant", "Leading Tone"],
      minor: ["Tonic", "Supertonic", "Mediant", "Subdominant", "Dominant", "Submediant", "Subtonic"],
      harmonicMinor: ["Tonic", "Supertonic", "Mediant", "Subdominant", "Dominant", "Submediant", "Leading Tone"]
    };

    // Show/hide custom tuning input based on instrument selection.
    const instrumentSelect = document.getElementById("instrument");
    const tuningGroup = document.getElementById("tuningGroup");
    instrumentSelect.addEventListener("change", function() {
      if (this.value === "piano") {
        tuningGroup.style.display = "none";
      } else {
        tuningGroup.style.display = "block";
        if (this.value === "6guitar") {
          document.getElementById("guitarTuning").value = defaultTuning6;
        } else if (this.value === "7guitar") {
          document.getElementById("guitarTuning").value = defaultTuning7;
        }
      }
    });
    instrumentSelect.dispatchEvent(new Event("change"));

    // Parse a tuning string into an array of objects { note, octave }.
    function parseGuitarTuning(tuningStr) {
      let parts = tuningStr.split(",");
      let tuning = [];
      for (let part of parts) {
        part = part.trim();
        let match = part.match(/^([A-G][#]?)(\d+)$/);
        if (match) {
          tuning.push({ note: match[1], octave: parseInt(match[2], 10) });
        }
      }
      return tuning;
    }

    // Compute a 7-note scale given a tonic and scale type.
    function computeScale(tonic, scaleType) {
      let intervals;
      if (scaleType === "major") {
        intervals = [2, 2, 1, 2, 2, 2, 1];
      } else if (scaleType === "minor") {
        intervals = [2, 1, 2, 2, 1, 2, 2];
      } else if (scaleType === "harmonicMinor") {
        intervals = [2, 1, 2, 2, 1, 3, 1];
      }
      let scale = [tonic];
      let currentIndex = notes.indexOf(tonic);
      for (let i = 0; i < intervals.length - 1; i++) {
        currentIndex = (currentIndex + intervals[i]) % 12;
        scale.push(notes[currentIndex]);
      }
      return scale;
    }

    // Compute chord notes (the chord is defined by its quality) given a chord root.
    // The first note is the chord's fundamental.
    function computeChordNotes(root, quality) {
      const formulas = {
        major: [0, 4, 7],
        minor: [0, 3, 7],
        diminished: [0, 3, 6],
        augmented: [0, 4, 8]
      };
      let intervals = formulas[quality];
      let rootIndex = notes.indexOf(root);
      return intervals.map(interval => notes[(rootIndex + interval) % 12]);
    }

    // Convert chord quality to a common chord symbol.
    function getChordSymbol(root, quality) {
      switch (quality) {
        case "major": return root;
        case "minor": return root + "m";
        case "diminished": return root + "°";
        case "augmented": return root + "+";
        default: return root;
      }
    }

    // Given a tuning object and a fret number, compute the produced pitch (e.g., "E2", "G#3").
    function getProducedPitch(tuningObj, fret) {
      let baseIndex = notes.indexOf(tuningObj.note);
      let total = baseIndex + fret;
      let producedNote = notes[total % 12];
      let octaveIncrease = Math.floor(total / 12);
      return producedNote + (tuningObj.octave + octaveIncrease);
    }

    // Recursive DFS candidate generator for a given fret span.
    function dfsCandidatesForSpan(chordNotes, tuning, minFret, maxFret, index, fundamentalFound, currentAssignment, results) {
      if (index === tuning.length) {
        results.push(currentAssignment.slice());
        return;
      }
      let options = [];
      let possible = [];
      // Option: open string.
      let openNote = tuning[index].note;
      if (chordNotes.includes(openNote)) {
        possible.push({ fret: 0, produced: openNote });
      }
      // Options for fretted notes.
      for (let fret = minFret; fret <= maxFret; fret++) {
        let produced = getProducedPitch(tuning[index], fret);
        let producedNote = produced.replace(/\d/, "");
        if (chordNotes.includes(producedNote)) {
          possible.push({ fret: fret, produced: producedNote });
        }
      }
      // If fundamental not yet found, restrict to options that produce the fundamental.
      if (!fundamentalFound) {
        let fundamentalOptions = possible.filter(opt => opt.produced === chordNotes[0]);
        if (fundamentalOptions.length > 0) {
          options = fundamentalOptions;
        } else {
          options = [];
        }
      } else {
        options = possible;
      }
      // Always allow mute.
      options.push("x");
      for (let opt of options) {
        let newFundamentalFound = fundamentalFound;
        if (opt !== "x" && !fundamentalFound) {
          if (opt.produced === chordNotes[0]) {
            newFundamentalFound = true;
          }
        }
        currentAssignment.push(opt === "x" ? "x" : opt.fret.toString());
        dfsCandidatesForSpan(chordNotes, tuning, minFret, maxFret, index + 1, newFundamentalFound, currentAssignment, results);
        currentAssignment.pop();
      }
    }

    // Wrapper: generate all candidate assignments for a given fret span.
    function generateCandidatesForSpan(chordNotes, tuning, minFret, maxFret) {
      let results = [];
      dfsCandidatesForSpan(chordNotes, tuning, minFret, maxFret, 0, false, [], results);
      return results;
    }

    // Filtering function: rejects candidate if:
    // - The first non-muted string's produced pitch (ignoring octave) is not the chord fundamental.
    // - The last 3 strings are muted.
    // - Duplicate produced pitches (with octave) occur.
    // - A muted string is isolated (i.e. a mute occurs between two sounded strings).
    function filterCandidate(candidate, tuning, chordNotes) {
      let producedPitches = candidate.map((assign, i) =>
        assign === "x" ? null : getProducedPitch(tuning[i], parseInt(assign))
      );
      let firstNonMuted = producedPitches.find(p => p !== null);
      if (!firstNonMuted || firstNonMuted.replace(/\d/, "") !== chordNotes[0]) return false;
      for (let i = tuning.length - 3; i < tuning.length; i++) {
        if (producedPitches[i] === null) return false;
      }
      let pitchSet = new Set();
      for (let p of producedPitches) {
        if (p !== null) {
          if (pitchSet.has(p)) return false;
          pitchSet.add(p);
        }
      }
      for (let i = 0; i < candidate.length; i++) {
        if (candidate[i] === "x") {
          let hasBefore = candidate.slice(0, i).some(a => a !== "x");
          let hasAfter = candidate.slice(i + 1).some(a => a !== "x");
          if (hasBefore && hasAfter) return false;
        }
      }
      return true;
    }

    // Main DFS candidate generation: iterate maxFret from 3 to 15.
    function computeGuitarFingerings(chordNotes, tuning) {
      let candidates = new Set();
      for (let maxFret = 3; maxFret <= 15; maxFret++) {
        let minFret = maxFret >= 4 ? maxFret - 3 : 1;
        let candidateArrays = generateCandidatesForSpan(chordNotes, tuning, minFret, maxFret);
        for (let cand of candidateArrays) {
          if (filterCandidate(cand, tuning, chordNotes)) {
            candidates.add(cand.join(" "));
          }
        }
      }
      return Array.from(candidates);
    }

    // For piano, simply return two variants.
    function computePianoFingerings(chordNotes) {
      let candidate1 = chordNotes.join(" ");
      let candidate2 = chordNotes.slice(1).concat(chordNotes[0]).join(" ");
      return [candidate1, candidate2];
    }

    // Generate chords: compute the scale, then for each degree compute chord and candidate fingerings.
    function generateChords(tonic, scaleType, instrument, customTuning) {
      let scale = computeScale(tonic, scaleType);
      let qualities = chordQualities[scaleType];
      let results = [];
      for (let i = 0; i < scale.length; i++) {
        let chordRoot = scale[i];
        let quality = qualities[i];
        let chordNotes = computeChordNotes(chordRoot, quality);
        let chordSymbol = getChordSymbol(chordRoot, quality);
        let fingerings;
        if (instrument === "6guitar" || instrument === "7guitar") {
          fingerings = computeGuitarFingerings(chordNotes, customTuning);
        } else if (instrument === "piano") {
          fingerings = computePianoFingerings(chordNotes);
        }
        results.push({
          degree: romanMapping[scaleType][i],
          functionLabel: functionsMapping[scaleType][i],
          chordSymbol: chordSymbol,
          chordNotes: chordNotes,
          fingerings: fingerings
        });
      }
      return results;
    }

    // Form submission handler.
    document.getElementById('scaleForm').addEventListener('submit', function(e) {
      e.preventDefault();
      const tonicInput = document.getElementById('tonic').value.trim();
      const tonic = tonicInput.charAt(0).toUpperCase() + tonicInput.slice(1);
      const scaleType = document.getElementById('scaleType').value;
      const instrument = document.getElementById('instrument').value;
      let customTuning = null;
      if (instrument === "6guitar" || instrument === "7guitar") {
        let tuningStr = document.getElementById('guitarTuning').value;
        customTuning = parseGuitarTuning(tuningStr);
        if (customTuning.length === 0) {
          customTuning = instrument === "6guitar" ? parseGuitarTuning(defaultTuning6) : parseGuitarTuning(defaultTuning7);
        }
      }
      const resultsDiv = document.getElementById('results');
      resultsDiv.innerHTML = '';
      if (!tonic || notes.indexOf(tonic) === -1) {
        resultsDiv.innerHTML = '<p>Please enter a valid tonic note (e.g., C, C#, D, etc.).</p>';
        return;
      }
      let chords = generateChords(tonic, scaleType, instrument, customTuning);
      let maxFingerings = chords.reduce((max, chord) => Math.max(max, chord.fingerings.length), 0);
      let table = document.createElement('table');
      table.classList.add('scale-table');
      let degreeRow = document.createElement('tr');
      let functionRow = document.createElement('tr');
      chords.forEach(chord => {
        let tdDegree = document.createElement('td');
        tdDegree.classList.add('scale-header');
        tdDegree.textContent = chord.degree;
        degreeRow.appendChild(tdDegree);
        let tdFunction = document.createElement('td');
        tdFunction.classList.add('scale-header');
        tdFunction.textContent = chord.functionLabel;
        functionRow.appendChild(tdFunction);
      });
      table.appendChild(degreeRow);
      table.appendChild(functionRow);
      let chordInfoRow = document.createElement('tr');
      chords.forEach(chord => {
        let td = document.createElement('td');
        td.classList.add('chord-details');
        td.innerHTML = `<strong>${chord.chordSymbol}</strong><br>Notes: ${chord.chordNotes.join(", ")}`;
        chordInfoRow.appendChild(td);
      });
      table.appendChild(chordInfoRow);
      for (let i = 0; i < maxFingerings; i++) {
        let row = document.createElement('tr');
        chords.forEach(chord => {
          let td = document.createElement('td');
          td.classList.add('chord-details');
          td.textContent = chord.fingerings[i] || "";
          row.appendChild(td);
        });
        table.appendChild(row);
      }
      resultsDiv.appendChild(table);
    });
  </script>
</body>
</html>
