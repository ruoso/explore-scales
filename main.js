import { getNotes, getTuningPresets, getScales, getFormulas, getGenres } from './constants.js';
import { renderChordSVG } from './chord-render.js';
import { generateChords, computeScale, generateHarmonicSequences } from './gen-scale.js';
import { prewarmFingeringCache } from './fingering.js';
import { renderScaleStaff } from './scale-render.js';
import { playScale } from './scale-audio.js';

// ============================
// Helper Functions
// ============================
// Parse a tuning string into an array of objects { note, octave }
function parseGuitarTuning(tuningStr) {
  let parts = tuningStr.split(",");
  let tuning = [];
  for (let part of parts) {
    part = part.trim();
    let match = part.match(/^([A-G][#]?)(\d+)$/);
    if (match) {
      tuning.push({ note: match[1], octave: parseInt(match[2], 10) });
    }
  }
  return tuning;
}

// If a note is flat (e.g., "Bb"), convert to its sharp equivalent (e.g., "A#")
function convertFlatToSharp(note) {
  const flatToSharp = { "Bb": "A#", "Db": "C#", "Eb": "D#", "Gb": "F#", "Ab": "G#" };
  return flatToSharp[note] || note;
}

// ============================
// Mode Catalogue
// ============================
const DEFAULT_MODE_KEY = 'major';

const MODE_GROUPS = [
  {
    id: 'diatonic',
    title: 'Diatonic Modes',
    description: 'Classic seven-note modes generated by rotating the major scale.',
    accent: '#4c6ef5',
    modes: [
      {
        key: 'major',
        title: 'Ionian',
        subtitle: 'Major',
        tagline: 'The familiar major landscape with a strong leading tone.',
        description: 'Ionian is the tonal home base of Western harmony, delivering clarity with its natural 4th and leading 7th degrees.',
        parent: 'Major scale',
        characteristic: 'Major 3rd with a natural 7 keeps cadences bright.'
      },
      {
        key: 'dorian',
        title: 'Dorian',
        subtitle: 'Minor ♮6',
        tagline: 'Supple minor colour with a lifted sixth degree.',
        description: 'Dorian keeps the minor third while brightening the sixth, creating a soulful modal palette favoured in jazz and folk.',
        parent: 'Major scale (mode II)',
        characteristic: 'Natural 6 over a minor triad softens the pull to the IV.'
      },
      {
        key: 'phrygian',
        title: 'Phrygian',
        subtitle: 'Minor ♭2',
        tagline: 'A darker minor mood anchored by the flat second.',
        description: 'Phrygian leans into drama with its ♭2 and ♭6, giving flamenco and film scores their signature tension.',
        parent: 'Major scale (mode III)',
        characteristic: 'Flat 2 rubbing against the tonic defines the bite.'
      },
      {
        key: 'lydian',
        title: 'Lydian',
        subtitle: 'Major ♯4',
        tagline: 'Floating major sonority with a shimmering raised fourth.',
        description: 'Lydian raises the subdominant, relaxing cadences for dreamy, expansive progressions.',
        parent: 'Major scale (mode IV)',
        characteristic: 'Raised 4th above a major base keeps the sound weightless.'
      },
      {
        key: 'mixolydian',
        title: 'Mixolydian',
        subtitle: 'Dominant',
        tagline: 'Blues-inflected major with a relaxed flat seventh.',
        description: 'Mixolydian fuels dominant vamps and blues jams by pairing a major third with a laid-back flat seventh.',
        parent: 'Major scale (mode V)',
        characteristic: 'Major 3rd plus flat 7 invites dominant resolutions.'
      },
      {
        key: 'naturalMinor',
        title: 'Aeolian',
        subtitle: 'Natural Minor',
        tagline: 'The classic minor palette with a flat sixth and seventh.',
        description: 'Aeolian underpins countless songs with its moody ♭6 and ♭7 over a minor tonic.',
        parent: 'Major scale (mode VI)',
        characteristic: 'Flat 6 and flat 7 deepen the minor atmosphere.'
      },
      {
        key: 'locrian',
        title: 'Locrian',
        subtitle: 'Diminished 5',
        tagline: 'Unstable mode built on a diminished tonic triad.',
        description: 'Locrian begins on the leading tone, producing a tense ♭2 and diminished 5 that demand resolution.',
        parent: 'Major scale (mode VII)',
        characteristic: 'Flat 2 and diminished 5 push strongly away from tonic.'
      }
    ]
  },
  {
    id: 'minorVariants',
    title: 'Minor Variants',
    description: 'Altered minor collections for classical, modal, and world colours.',
    accent: '#8e44ad',
    modes: [
      {
        key: 'harmonicMinor',
        title: 'Harmonic Minor',
        subtitle: 'Minor ♮7',
        tagline: 'Dramatic minor with a leading tone for cadences.',
        description: 'Harmonic minor lifts the seventh to sharpen dominant motion while keeping the dark flat sixth.',
        parent: 'Natural minor with raised 7',
        characteristic: 'Augmented 2nd between ♭6 and ♮7 heightens the pull.'
      },
      {
        key: 'melodicMinor',
        title: 'Melodic Minor',
        subtitle: 'Jazz Minor',
        tagline: 'Smooth hybrid of major and minor for modern harmony.',
        description: 'Melodic minor (ascending) keeps the minor third but raises the 6th and 7th, creating a sleek, contemporary colour.',
        parent: 'Minor with raised 6 & 7',
        characteristic: 'Minor 3 with natural 6 and 7 balances melancholy and lift.'
      },
      {
        key: 'hungarianMinor',
        title: 'Hungarian Minor',
        subtitle: 'Minor ♯4',
        tagline: 'Eastern European flair with augmented leaps.',
        description: 'Hungarian minor injects a raised 4th and leading tone, producing gypsy-inspired tension and sweep.',
        parent: 'Harmonic minor variant',
        characteristic: 'Raised 4 and wide augmented seconds stand out.'
      },
      {
        key: 'spanishPhrygian',
        title: 'Spanish Phrygian',
        subtitle: 'Phrygian Dominant',
        tagline: 'Flamenco heat with a major third over Phrygian roots.',
        description: 'Also called Phrygian dominant, this mode brightens Phrygian by sharpening the third for an exotic dominant sonority.',
        parent: 'Harmonic minor mode V',
        characteristic: 'Flat 2 paired with major 3 fuels flamenco cadences.'
      },
      {
        key: 'neapolitanMinor',
        title: 'Neapolitan Minor',
        subtitle: 'Minor ♭2 ♮7',
        tagline: 'Romantic-era minor with rich flat second colour.',
        description: 'Neapolitan minor combines a Phrygian-style ♭2 with a leading tone for dramatic classical gestures.',
        parent: 'Neapolitan collection',
        characteristic: 'Flat 2 plus natural 7 intensify the dominant pull.'
      },
      {
        key: 'persian',
        title: 'Persian',
        subtitle: 'Minor with ♭2 ♮7',
        tagline: 'Middle Eastern inflection built on stacked augmented seconds.',
        description: 'The Persian scale highlights augmented seconds between ♭2–3 and ♭6–♮7 for a distinctive Middle Eastern flavour.',
        parent: 'Harmonic minor variant',
        characteristic: 'Wide augmented seconds and flat 2 shape the contour.'
      }
    ]
  },
  {
    id: 'pentatonic',
    title: 'Pentatonic & Folk',
    description: 'Five-note shapes and folk-inspired colours for melody and improvisation.',
    accent: '#e67e22',
    modes: [
      {
        key: 'majorPentatonic',
        title: 'Major Pentatonic',
        subtitle: '5-note Major',
        tagline: 'Open major sound free of half-steps.',
        description: 'Major pentatonic removes semitone tension for melodies that float effortlessly over simple harmony.',
        parent: 'Pentatonic collection',
        characteristic: 'No 4 or 7 keeps the sound wide and consonant.'
      },
      {
        key: 'minorPentatonic',
        title: 'Minor Pentatonic',
        subtitle: '5-note Minor',
        tagline: 'Blues-ready minor without the 2 and 6.',
        description: 'Minor pentatonic supplies the essential blues tones while avoiding clashing seconds.',
        parent: 'Pentatonic collection',
        characteristic: 'Minor 3rd and flat 7 anchor the groove.'
      },
      {
        key: 'blues',
        title: 'Blues Hexatonic',
        subtitle: 'Minor + ♭5',
        tagline: 'Adds the blue note to the minor pentatonic.',
        description: 'The blues scale inserts the flattened fifth for gritty bends and call-and-response phrases.',
        parent: 'Pentatonic extension',
        characteristic: 'Flat 5 (“blue note”) creates vocal tension.'
      },
      {
        key: 'hirajoshi',
        title: 'Hirajoshi',
        subtitle: 'Japanese Pentatonic',
        tagline: 'Sparse, haunting pentatonic from koto repertoire.',
        description: 'Hirajoshi alternates whole and half steps for a hollow, introspective timbre.',
        parent: 'Japanese pentatonic',
        characteristic: 'Half-step between 2 and ♭3 delivers its sighing quality.'
      },
      {
        key: 'inScale',
        title: 'In Sen',
        subtitle: 'Japanese Mode',
        tagline: 'Expressive Japanese mode with a minor second.',
        description: 'In Sen emphasises a semitone at the top, yielding a sharp yet melodic contour for lyrical phrases.',
        parent: 'Japanese pentatonic',
        characteristic: 'Flat 2 and 5 against a pentatonic frame.'
      }
    ]
  },
  {
    id: 'jazz',
    title: 'Jazz & Bebop',
    description: 'Extended collections tailored for flowing, chord-aligned lines.',
    accent: '#16a085',
    modes: [
      {
        key: 'bebopMajor',
        title: 'Bebop Major',
        subtitle: 'Ionian + ♭7',
        tagline: 'Major scale with a passing flat seven for swing phrasing.',
        description: 'Bebop major inserts a chromatic ♭7 so chord tones land on strong beats during fast lines.',
        parent: 'Major scale with passing tone',
        characteristic: 'Both ♮7 and ♭7 available between 6 and 1.'
      },
      {
        key: 'bebopDominant',
        title: 'Bebop Dominant',
        subtitle: 'Mixolydian + ♮7',
        tagline: 'Dominant scale with an added natural seventh.',
        description: 'Bebop dominant keeps the dominant ♭7 but adds a natural 7 for seamless bebop phrasing over V7 chords.',
        parent: 'Mixolydian with passing tone',
        characteristic: 'Carries both ♭7 and ♮7 for chromatic dominant runs.'
      },
      {
        key: 'bebopMinor',
        title: 'Bebop Minor',
        subtitle: 'Dorian + ♮7',
        tagline: 'Dorian flavour with a raised seventh passing tone.',
        description: 'Bebop minor outlines minor ii chords while preserving eighth-note symmetry via the natural 7.',
        parent: 'Dorian with passing tone',
        characteristic: 'Minor 3 with both ♭7 and ♮7 for bebop flow.'
      },
      {
        key: 'majorLocrian',
        title: 'Major Locrian',
        subtitle: 'Locrian ♮2',
        tagline: 'Locrian softened by a natural second.',
        description: 'Major locrian keeps the diminished fifth but raises the second for more usable chord tones in jazz harmony.',
        parent: 'Melodic minor mode VI',
        characteristic: 'Natural 2 with diminished 5 balances tension and clarity.'
      }
    ]
  },
  {
    id: 'symmetric',
    title: 'Symmetric & Altered',
    description: 'Symmetrical and highly coloured collections for modern harmony.',
    accent: '#e74c3c',
    modes: [
      {
        key: 'wholeTone',
        title: 'Whole Tone',
        subtitle: 'Augmented Scale',
        tagline: 'Equidistant whole steps for dreamy dominant chords.',
        description: 'The whole tone scale erases leading tones, ideal for augmented dominant sounds and impressionistic textures.',
        parent: 'Symmetric six-note',
        characteristic: 'Only whole steps; no semitones to resolve.'
      },
      {
        key: 'diminishedHalfWhole',
        title: 'Half-Whole Diminished',
        subtitle: 'Dominant Diminished',
        tagline: 'Alternating half and whole steps starting with half.',
        description: 'Half-whole diminished targets dominant chords with every altered tension ready for chromatic movement.',
        parent: 'Octatonic (half-whole)',
        characteristic: 'Contains ♭9, ♯9, ♯11, and 13 over V7.'
      },
      {
        key: 'diminishedWholeHalf',
        title: 'Whole-Half Diminished',
        subtitle: 'Diminished',
        tagline: 'Octatonic sequence starting on a whole step.',
        description: 'Whole-half diminished suits fully diminished chords and modulating sequences built on minor thirds.',
        parent: 'Octatonic (whole-half)',
        characteristic: 'Symmetric minor thirds outline diminished arpeggios.'
      },
      {
        key: 'augmented',
        title: 'Augmented',
        subtitle: 'Symmetric',
        tagline: 'Alternating minor third and semitone for chromatic glides.',
        description: 'The augmented scale cycles m3 and semitone intervals, enabling slippery augmented triad movements.',
        parent: 'Symmetric hexatonic',
        characteristic: 'Built from two interlocking augmented triads.'
      },
      {
        key: 'neapolitanMajor',
        title: 'Neapolitan Major',
        subtitle: 'Major ♭2',
        tagline: 'Major colour tinted by the lowered second degree.',
        description: 'Neapolitan major combines a lush flat 2 with bright major thirds and sixths for cinematic shifts.',
        parent: 'Neapolitan collection',
        characteristic: 'Flat 2 against a major tonic delivers instant drama.'
      },
      {
        key: 'enigmatic',
        title: 'Enigmatic',
        subtitle: 'Chromatic Puzzle',
        tagline: 'Stepwise yet mysterious with stacked augmented seconds.',
        description: 'The enigmatic scale climbs with unusual intervals, creating unresolved, impressionistic phrases.',
        parent: 'Symmetric-inspired',
        characteristic: 'Consecutive semitones followed by wide leaps.'
      }
    ]
  }
];

// ============================
// Chord and Scale Mappings
// ============================
// New constant for chord extension intervals (in semitones)
const extensionIntervals = {
  "7": 10,
  "9": 14,
  "11": 17,
  "13": 21
};

// New function to calculate chord notes including extensions
async function calculateChordNotes(rootIndex, chordType, selectedExtensions) {
  const notes = await getNotes();
  const formulas = await getFormulas();
  const baseFormula = formulas[chordType];
  const chordNotes = baseFormula.map(interval => notes[(rootIndex + interval) % notes.length]);
  
  selectedExtensions.forEach(ext => {
    if (extensionIntervals[ext] !== undefined) {
      chordNotes.push(notes[(rootIndex + extensionIntervals[ext]) % notes.length]);
    }
  });
  return chordNotes;
}

function findModeConfig(modeKey) {
  for (const group of MODE_GROUPS) {
    const mode = group.modes.find(m => m.key === modeKey);
    if (mode) {
      return { group, mode };
    }
  }
  return null;
}

function formatIntervalPattern(pattern = []) {
  if (!Array.isArray(pattern) || pattern.length === 0) {
    return '—';
  }
  return pattern.map(step => {
    switch (step) {
      case 1:
        return 'H';
      case 2:
        return 'W';
      case 3:
        return 'm3';
      case 4:
        return 'M3';
      default:
        return `${step}`;
    }
  }).join(' – ');
}

function highlightSelectedMode(modeKey) {
  modeCardMap.forEach((card, key) => {
    if (!card) return;
    const isActive = key === modeKey;
    card.classList.toggle('is-active', isActive);
    card.setAttribute('aria-pressed', isActive ? 'true' : 'false');
  });
}

function updateModeDetailElements(config, scaleData) {
  const group = config ? config.group : null;
  const mode = config ? config.mode : null;
  if (selectedModeFamilyEl) {
    selectedModeFamilyEl.textContent = group ? group.title : 'Mode';
  }
  if (selectedModeTitleEl) {
    selectedModeTitleEl.textContent = mode ? mode.title : 'Select a mode';
  }
  if (selectedModeSubtitleEl) {
    selectedModeSubtitleEl.textContent = mode && mode.subtitle ? mode.subtitle : '';
  }
  if (selectedModeDescriptionEl) {
    selectedModeDescriptionEl.textContent = mode && mode.description ? mode.description : (mode && mode.tagline ? mode.tagline : '');
  }
  if (selectedModeParentEl) {
    selectedModeParentEl.textContent = mode && mode.parent ? mode.parent : '—';
  }
  if (selectedModeCharacteristicEl) {
    selectedModeCharacteristicEl.textContent = mode && mode.characteristic ? mode.characteristic : '—';
  }
  if (selectedModePatternEl) {
    selectedModePatternEl.textContent = formatIntervalPattern(scaleData ? scaleData.pattern : []);
  }
}

function initializeModeBrowser() {
  if (!modeGrid) return;

  modeCardMap.clear();
  modeGrid.innerHTML = '';

  if (modeGroupSelectElement) {
    modeGroupSelectElement.innerHTML = '';
    const allOption = document.createElement('option');
    allOption.value = 'all';
    allOption.textContent = 'All families';
    modeGroupSelectElement.appendChild(allOption);
  }

  MODE_GROUPS.forEach(group => {
    if (modeGroupSelectElement) {
      const option = document.createElement('option');
      option.value = group.id;
      option.textContent = group.title;
      modeGroupSelectElement.appendChild(option);
    }

    const section = document.createElement('section');
    section.className = 'mode-group';
    section.dataset.groupId = group.id;

    const header = document.createElement('header');
    header.className = 'mode-group-header';
    const title = document.createElement('h3');
    title.textContent = group.title;
    const description = document.createElement('p');
    description.textContent = group.description;
    header.appendChild(title);
    header.appendChild(description);
    section.appendChild(header);

    const grid = document.createElement('div');
    grid.className = 'mode-card-grid';

    group.modes.forEach(mode => {
      const card = document.createElement('button');
      card.type = 'button';
      card.className = 'mode-card';
      card.dataset.modeKey = mode.key;
      card.style.setProperty('--mode-accent', mode.accent || group.accent);
      card.setAttribute('aria-pressed', 'false');
      card.setAttribute('aria-label', `${mode.title} mode`);

      const label = document.createElement('span');
      label.className = 'mode-card-label';
      label.textContent = mode.title;
      const subtitle = document.createElement('span');
      subtitle.className = 'mode-card-sub';
      subtitle.textContent = mode.subtitle || '';
      const tagline = document.createElement('p');
      tagline.className = 'mode-card-tagline';
      tagline.textContent = mode.tagline || '';

      card.appendChild(label);
      card.appendChild(subtitle);
      card.appendChild(tagline);

      card.addEventListener('click', () => {
        selectMode(mode.key);
      });

      grid.appendChild(card);
      modeCardMap.set(mode.key, card);
    });

    section.appendChild(grid);
    modeGrid.appendChild(section);
  });

  if (modeGroupSelectElement) {
    modeGroupSelectElement.addEventListener('change', () => {
      const targetGroup = modeGroupSelectElement.value;
      document.querySelectorAll('.mode-group').forEach(section => {
        const matches = targetGroup === 'all' || section.dataset.groupId === targetGroup;
        section.classList.toggle('mode-group-hidden', !matches);
      });
    });
    modeGroupSelectElement.value = 'all';
  }
}

async function selectMode(modeKey, options = {}) {
  if (!modeKey) return;
  const { deferUpdate = false } = options;
  const config = findModeConfig(modeKey);
  const scales = await getScales();
  const scaleData = scales[modeKey];

  if (!config || !scaleData) {
    console.warn(`Mode configuration missing for key: ${modeKey}`);
    return;
  }

  selectedModeKey = modeKey;

  if (scaleTypeSelect) {
    scaleTypeSelect.value = modeKey;
  }

  highlightSelectedMode(modeKey);
  updateModeDetailElements(config, scaleData);

  if (!deferUpdate) {
    await updateScaleNotes();
    await generateChordsFromForm();
  }
}

async function applyGenreFilter(selectedGenre) {
  activeGenreKey = selectedGenre || '';
  highlightedModes = new Set();

  if (activeGenreKey) {
    const genres = await getGenres();
    const genreData = genres[activeGenreKey];
    if (genreData && Array.isArray(genreData.scales)) {
      genreData.scales.forEach(key => highlightedModes.add(key));
    }
  }

  const hasFilter = highlightedModes.size > 0;
  modeCardMap.forEach((card, key) => {
    if (!card) return;
    const isRelevant = !hasFilter || highlightedModes.has(key);
    card.classList.toggle('mode-card-muted', hasFilter && !isRelevant);
    card.setAttribute('aria-hidden', hasFilter && !isRelevant ? 'true' : 'false');
  });

  if (hasFilter && !highlightedModes.has(selectedModeKey)) {
    const iterator = highlightedModes.values().next();
    if (!iterator.done) {
      await selectMode(iterator.value, { deferUpdate: true });
    }
  }
}

// ============================
// Tuning Controls and Query Parameter Functions
// ============================

const instrumentSelect = document.getElementById("instrument");
const tonicSelect = document.getElementById("tonic");
const scaleTypeSelect = document.getElementById("scaleType");
const scaleNotesDiv = document.getElementById("scaleNotes");
const modeGrid = document.getElementById('modeGrid');
const modeGroupSelectElement = document.getElementById('modeGroupSelect');
const selectedModeFamilyEl = document.getElementById('selectedModeFamily');
const selectedModeTitleEl = document.getElementById('selectedModeTitle');
const selectedModeSubtitleEl = document.getElementById('selectedModeSubtitle');
const selectedModePatternEl = document.getElementById('selectedModePattern');
const selectedModeDescriptionEl = document.getElementById('selectedModeDescription');
const selectedModeParentEl = document.getElementById('selectedModeParent');
const selectedModeCharacteristicEl = document.getElementById('selectedModeCharacteristic');

const modeCardMap = new Map();
let selectedModeKey = null;
let activeGenreKey = '';
let highlightedModes = new Set();

async function populateTuningPresets(instrument) {
  const tuningPresets = await getTuningPresets();
  const tuningPresetSelect = document.getElementById('tuningPreset');
  tuningPresetSelect.innerHTML = "";
  const presets = tuningPresets[instrument];
  if (presets) {
    presets.forEach(preset => {
      const option = document.createElement('option');
      option.value = preset.tuning;
      option.textContent = `${preset.name} (${preset.tuning})`;
      tuningPresetSelect.appendChild(option);
    });
  }
  // Set the tuningPreset value from the query parameter if it exists
  const params = getQueryParams();
  if (params.tuningPreset) {
    tuningPresetSelect.value = params.tuningPreset;
  }
}

function getQueryParams() {
  let params = {};
  let search = window.location.search;
  if (search.length > 1) {
    search.substring(1).split("&").forEach(function(item) {
      let parts = item.split("=");
      let key = decodeURIComponent(parts[0].replace(/\+/g, " "));
      let value = decodeURIComponent((parts[1] || "").replace(/\+/g, " "));
      params[key] = value;
    });
  }
  return params;
}

async function populateFormFromQuery() {
  const params = getQueryParams();
  if (params.tonic) {
    document.getElementById("tonic").value = params.tonic;
  }
  if (params.genre) {
    document.getElementById("genre").value = params.genre;
    await populateScalesForGenre(params.genre);
  }
  if (params.scaleType) {
    await selectMode(params.scaleType, { deferUpdate: true });
  }
  for (let i = 1; i <= 8; i++) {
    if (params[`extensions-${i}`]) {
      document.getElementById(`extensions-${i}`).value = params[`extensions-${i}`];
    }
  }
  if (params.instrument) {
    document.getElementById("instrument").value = params.instrument;
  }
  if (params.customTuning && document.getElementById("customTuning")) {
    document.getElementById("customTuning").value = params.customTuning;
  }
  // Call populateTuningPresets after the form is fully populated
  if (params.instrument) {
    await populateTuningPresets(params.instrument);
    if (params.tuningPreset && document.getElementById("tuningPreset")) {
      document.getElementById("tuningPreset").value = params.tuningPreset;
    }
  }
}

// Populate genre, scale type and instrument selects
async function populateSelects() {
  const tuningPresets = await getTuningPresets();
  const genres = await getGenres();
  const genreSelect = document.getElementById('genre');
  const instrumentSelect = document.getElementById('instrument');

  if (genreSelect) {
    genreSelect.innerHTML = '<option value="">All styles</option>';
    for (const [key, value] of Object.entries(genres)) {
      const option = document.createElement('option');
      option.value = key;
      option.textContent = value.name;
      genreSelect.appendChild(option);
    }
  }

  if (instrumentSelect) {
    instrumentSelect.innerHTML = '';
    for (const key of Object.keys(tuningPresets)) {
      const option = document.createElement('option');
      option.value = key;
      const instrumentName = key.replace(/\d/g, '');
      const stringCount = key.replace(/\D/g, '');
      option.textContent = stringCount ? `${instrumentName} (${stringCount}‑String)` : instrumentName;
      instrumentSelect.appendChild(option);
    }
  }
}

// Apply genre filter to the mode grid
async function populateScalesForGenre(selectedGenre) {
  await applyGenreFilter(selectedGenre);
}

function appendFingeringRow(table, chords, customTuning) {
  let i = 0;
  while (true) {
    let hasFingerings = false;
    let row = document.createElement('tr');
    chords.forEach(chord => {
      let td = document.createElement('td');
      td.classList.add('chord-details');
      if (chord.fingerings[i]) {
        td.innerHTML = renderChordSVG(chord.fingerings[i], customTuning);
        hasFingerings = true;
      } else {
        td.textContent = "";
      }
      row.appendChild(td);
    });
    if (hasFingerings) {
      table.appendChild(row);
      i++;
    } else {
      break;
    }
  }
}

async function generateChordsFromForm() {
  const tonicInput = document.getElementById('tonic').value.trim();
  // Preserve the original tonic for display (e.g., "Bb")
  const displayTonic = tonicInput;
  // For computation, if tonic contains "b", convert to its sharp equivalent.
  const normalizedTonic = tonicInput.includes("b") ? convertFlatToSharp(tonicInput) : tonicInput;
  const scaleType = document.getElementById('scaleType').value;
  
  console.log(`Generating chords for tonic: "${normalizedTonic}", scaleType: "${scaleType}"`);
  
  // Check if scaleType is valid
  if (!scaleType) {
    console.log('No scale type selected, skipping chord generation');
    return;
  }
  
  const instrument = document.getElementById('instrument').value;
  const tuningPresets = await getTuningPresets();
  let customTuning = null;
  if (tuningPresets[instrument]) {
    let presetSelect = document.getElementById("tuningPreset");
    let presetTuningStr = presetSelect.value;
    let customTuningStr = document.getElementById("customTuning").value.trim();
    let tuningStr = customTuningStr !== "" ? customTuningStr : presetTuningStr;
    customTuning = parseGuitarTuning(tuningStr);
  }
  const resultsDiv = document.getElementById('results');
  resultsDiv.innerHTML = '';
  const notes = await getNotes();
  if (!normalizedTonic || (notes.indexOf(normalizedTonic) === -1 && !normalizedTonic.includes("b"))) {
    resultsDiv.innerHTML = '<p>Please enter a valid tonic note (e.g., C, C#, D, Bb, etc.).</p>';
    return;
  }

  // extract extensions from form checkboxes

  let extensions = [];
  for (let i = 1; i <= 8; i++) {
    let ext = document.getElementById(`extensions-${i}`).value;
    extensions.push(ext);
  }
  let chords = await generateChords(normalizedTonic, scaleType, extensions, instrument, customTuning, displayTonic);
  let table = document.createElement('table');
  table.classList.add('scale-table');
  let degreeRow = document.createElement('tr');
  let functionRow = document.createElement('tr');
  chords.forEach(chord => {
    let tdDegree = document.createElement('td');
    tdDegree.classList.add('scale-header');
    tdDegree.textContent = chord.degree;
    degreeRow.appendChild(tdDegree);
    let tdFunction = document.createElement('td');
    tdFunction.classList.add('scale-header');
    tdFunction.textContent = chord.functionLabel;
    functionRow.appendChild(tdFunction);
  });
  table.appendChild(degreeRow);
  table.appendChild(functionRow);
  
  let chordSymbolRow = document.createElement('tr');
  chords.forEach((chord, index) => {
    let td = document.createElement('td');
    td.classList.add('chord-details');
    let extensionsInputName = `extensions-${index}`;
    td.innerHTML = `<strong>${chord.chordSymbol}</strong>`;
    chordSymbolRow.appendChild(td);
  });
  table.appendChild(chordSymbolRow);

  let chordFinalNotesRow = document.createElement('tr');
  chords.forEach((chord, index) => {
    let td = document.createElement('td');
    td.classList.add('chord-details');
    td.innerHTML = chord.chordNotes.join(", ");
    chordFinalNotesRow.appendChild(td);
  });
  table.appendChild(chordFinalNotesRow);

  appendFingeringRow(table, chords, customTuning);
  resultsDiv.appendChild(table);
  
  // Generate and display harmonic sequences in parallel with chord generation
  const selectedGenre = document.getElementById('genre').value;
  const harmonicSequencesPromise = displayHarmonicSequences(normalizedTonic, scaleType, extensions, displayTonic, customTuning, selectedGenre);
  
  // Wait for harmonic sequences to complete
  await harmonicSequencesPromise;
}

async function displayHarmonicSequences(tonic, scaleType, extensionsArr, displayTonic, customTuning, selectedGenre) {
  const harmonicSequencesDiv = document.getElementById('harmonicSequences');
  const sequences = await generateHarmonicSequences(tonic, scaleType, extensionsArr, displayTonic, customTuning, selectedGenre);
  
  // Store globally for fingering navigation
  window.currentSequences = sequences;
  window.currentCustomTuning = customTuning;
  
  console.log('Debug - scaleType:', scaleType);
  console.log('Debug - sequences generated:', sequences);
  
  if (sequences.length === 0) {
    harmonicSequencesDiv.innerHTML = '<p>No harmonic sequences available for this scale type.</p>';
    return;
  }
  
  let html = '<h2>Common Harmonic Sequences</h2>';
  
  sequences.forEach(sequence => {
    html += `<div class="sequence-container">
      <h3>${sequence.name}</h3>
      <div class="sequence-table-container">
        <table class="sequence-table">
          <tr class="sequence-header">
            <td><strong>Functional</strong></td>`;
    
    sequence.chords.forEach(chord => {
      html += `<td>${chord.functional}</td>`;
    });
    
    html += `</tr>
          <tr class="sequence-header">
            <td><strong>Roman Numeral</strong></td>`;
    
    sequence.chords.forEach(chord => {
      html += `<td>${chord.roman}</td>`;
    });
    
    html += `</tr>
          <tr class="sequence-header">
            <td><strong>Chord Symbol</strong></td>`;
    
    sequence.chords.forEach(chord => {
      html += `<td><strong>${chord.chordSymbol}</strong></td>`;
    });
    
    html += `</tr>
          <tr>
            <td><strong>Notes</strong></td>`;
    
    sequence.chords.forEach(chord => {
      html += `<td class="chord-notes">${chord.chordNotes.join(', ')}</td>`;
    });
    
    html += `</tr>`;
    
    // Add examples if they exist
    if (sequence.examples && sequence.examples.length > 0) {
      html += `<tr class="sequence-header">
            <td><strong>Examples</strong></td>
            <td class="examples-cell" colspan="${sequence.chords.length}">`;
      
      sequence.examples.forEach((example, index) => {
        html += `<div class="example-piece">
          <span class="example-title">${example.title}</span>
          <span class="example-composer">by ${example.composer}</span>
        </div>`;
        if (index < sequence.examples.length - 1) {
          html += `<br>`;
        }
      });
      
      html += `</td></tr>`;
    }
    
    // Add fingerings row if tuning is available
    if (customTuning && sequence.chords.some(chord => chord.fingerings && chord.fingerings.length > 0)) {
      html += `<tr class="sequence-header">
            <td><strong>Fingerings</strong></td>`;
      
      sequence.chords.forEach((chord, chordIndex) => {
        html += `<td class="fingering-cell" data-sequence="${sequence.name}" data-chord="${chordIndex}">`;
        
        if (chord.fingerings && chord.fingerings.length > 0) {
          html += `<div class="fingering-container">
            <div class="fingering-nav">
              <button class="fingering-btn prev" onclick="cycleFingering('${sequence.name}', ${chordIndex}, -1)" ${chord.fingerings.length <= 1 ? 'disabled' : ''}>‹</button>
              <span class="fingering-counter">1/${chord.fingerings.length}</span>
              <button class="fingering-btn next" onclick="cycleFingering('${sequence.name}', ${chordIndex}, 1)" ${chord.fingerings.length <= 1 ? 'disabled' : ''}>›</button>
            </div>
            <div class="fingering-display">
              ${renderChordSVG(chord.fingerings[0], customTuning)}
            </div>
          </div>`;
        } else {
          html += `<div class="no-fingering">No fingerings available</div>`;
        }
        
        html += `</td>`;
      });
      
      html += `</tr>`;
    }
    
    html += `</table>
      </div>
    </div>`;
  });
  
  harmonicSequencesDiv.innerHTML = html;
}

// Global function to cycle through fingerings
window.cycleFingering = function(sequenceName, chordIndex, direction) {
  const cell = document.querySelector(`[data-sequence="${sequenceName}"][data-chord="${chordIndex}"]`);
  if (!cell) return;
  
  const display = cell.querySelector('.fingering-display');
  const counter = cell.querySelector('.fingering-counter');
  
  // Get current fingering index from counter
  let currentIndex = parseInt(counter.textContent.split('/')[0]) - 1;
  let totalFingerings = parseInt(counter.textContent.split('/')[1]);
  
  // Calculate new index
  currentIndex += direction;
  if (currentIndex < 0) currentIndex = totalFingerings - 1;
  if (currentIndex >= totalFingerings) currentIndex = 0;
  
  // Update counter
  counter.textContent = `${currentIndex + 1}/${totalFingerings}`;
  
  // Get the chord data to render new fingering
  const sequences = window.currentSequences || [];
  const sequence = sequences.find(s => s.name === sequenceName);
  if (sequence && sequence.chords[chordIndex] && sequence.chords[chordIndex].fingerings) {
    const newFingering = sequence.chords[chordIndex].fingerings[currentIndex];
    const customTuning = window.currentCustomTuning;
    if (newFingering && customTuning) {
      display.innerHTML = renderChordSVG(newFingering, customTuning);
    }
  }
};

// Event delegation: update chord notes when an extension checkbox changes
document.addEventListener('change', async function(e) {
  if (e.target.classList.contains('chord-extension')) {
    let container = e.target.closest('.extensions');
    // Get the chord's base root and chord type from data attributes
    const rootNote = container.getAttribute('data-root');
    const chordType = container.getAttribute('data-chord-type');
    const notes = await getNotes();
    const rootIndex = notes.indexOf(rootNote);
    // Gather checked extension values from this container
    const selectedExtNodes = container.querySelectorAll('.chord-extension:checked');
    const selectedExtensions = Array.from(selectedExtNodes).map(el => el.value);
    // Calculate new chord notes using the updated extensions
    const newChordNotes = await calculateChordNotes(rootIndex, chordType, selectedExtensions);
    // Update the sibling element displaying the chord notes
    const td = container.parentElement;
    let notesDiv = td.querySelector('.updated-notes');
    if (notesDiv) {
      notesDiv.innerHTML = `Chord Notes: ${newChordNotes.join(", ")}`;
    }
  }
});

async function updateScaleNotes() {
  const tonic = tonicSelect.value;
  const scaleType = scaleTypeSelect.value;
  if (tonic && scaleType) {
    const scale = await computeScale(tonic, scaleType);
    scaleNotesDiv.innerHTML = renderScaleStaff(scale);
  }
}

async function playScaleFromForm() {
  const tonic = document.getElementById('tonic').value;
  const scaleType = document.getElementById('scaleType').value;
  if (tonic && scaleType) {
    const scale = await computeScale(tonic, scaleType);
    playScale(scale);
  }
}

tonicSelect.addEventListener("change", async () => {
  await updateScaleNotes();
  await generateChordsFromForm();
});

// Removed handleInputChange - now using direct event listeners

// Call populateSelects on page load
document.addEventListener('DOMContentLoaded', async () => {
  try {
    await populateSelects();

    if (instrumentSelect && instrumentSelect.value) {
      await populateTuningPresets(instrumentSelect.value);
    }

    initializeModeBrowser();

    const genreSelect = document.getElementById('genre');
    const initialGenre = genreSelect ? genreSelect.value : '';
    await populateScalesForGenre(initialGenre);

    await populateFormFromQuery();

    if (!selectedModeKey) {
      await selectMode(DEFAULT_MODE_KEY, { deferUpdate: true });
    }

    await updateScaleNotes();
    await generateChordsFromForm();

    // Prewarm the fingering cache for better performance
    prewarmFingeringCache(); // Run in background, don't wait

    const playScaleBtn = document.getElementById("playScaleBtn");
    if (playScaleBtn) {
      playScaleBtn.addEventListener("click", playScaleFromForm);
    }

    if (genreSelect) {
      genreSelect.addEventListener("change", async () => {
        const selectedGenre = genreSelect.value;
        await populateScalesForGenre(selectedGenre);
        await generateChordsFromForm();
        await updateScaleNotes();
      });
    }

    if (instrumentSelect) {
      instrumentSelect.addEventListener("change", async () => {
        await populateTuningPresets(instrumentSelect.value);
        await generateChordsFromForm();
        await updateScaleNotes();
      });
    }

    const generateChordsBtn = document.getElementById("generateChordsBtn");
    if (generateChordsBtn) {
      generateChordsBtn.addEventListener("click", async () => {
        await generateChordsFromForm();
      });
    }

    const scaleForm = document.getElementById("scaleForm");
    if (scaleForm) {
      scaleForm.addEventListener("submit", (e) => {
        e.preventDefault();
        generateChordsFromForm();
      });
    }
  } catch (error) {
    console.error('Error initializing application:', error);
    document.getElementById('results').innerHTML = '<p>Error loading music data. Please refresh the page.</p>';
  }
});

